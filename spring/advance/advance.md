### 템플릿 메서드 패턴

- 장점
    - 핵심 기능과 부가기능을 나눌 수 있음
- 단점
    - 기존 로직을 건드려야함

### 프록시 패턴 vs 데코레이터 패턴

프록시 패턴 : 접근 제어가 목적  
데코레이터 패턴 : 새로운 기능 추가가 목적

### 프록시 패턴

- 장점
    - 기존 로직을 건들지 않아도 됨
- 단점
    - 적용 대상이 100개면 프록시 클래스도 100개 만들어야 함

### 인터페이스 기반 프록시 vs 클래스 기반 프록시

- 인터페이스가 없어도 클래스 기반으로 프록시를 생성 가능
- 클래스 기반 프록시는 해당 클래스에만 적용 가능, 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용 가능

### 클래스 기반 프록시 제약

- 부모 클래스의 생성자를 호출해야함
- 클래스에 final 키워드가 붙으면 상속이 불가능
- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 x

### 리플렉션 사용하지 말자

애플리케이션을 동적으로 만들 수 있지만 컴파일 단계에서 오류를 잡아내지 못함

`getMethod("callA")` 을 실수로 `getMethod("callZ")` 로 해도 컴파일 오류 x

프로그래밍 언어가 발달하면서 타입 정보를 기반으로 컴파일 시점에 오류를 잡아준 덕분에 편했는데, 리플렉션은 그것을 역행하는 방식

JDK 동적 프록시는 인터페이를 구현 (implements) CGLIB은 구체 클래스를 상속(extends)

### CGLIB 제약

클래스 기반 프록시는 상속을 사용

- 부모 클래스의 생성자를 체크 -> CGLIB은 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요
- 클래스에 `final`키워드가 붙으면 상속 불가능 -> CGLIB에선 예외가 발생
- 메서드에 `final` 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없음 -> CGLIB에서는 프록시 로직이 동작 x

### 프록시 팩토리
- 인터페이스가 있는 경우에 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에 CGLIB을 적용하려면?
  - 프록시 팩토리를 이용해 둘 대신에 `Adivce` 를 사용하면 됨

```java
Target target = new Target();
ProxyFactory proxyFactory = new ProxyFactory(tartget);
proxyFactory.addAdvice(new TimeAdvice());
proxyFactory.getProxy();
// proxyFactory.setProxyTargetClass(true) 인터페이스가 있어도 무조건 CGLIB
```