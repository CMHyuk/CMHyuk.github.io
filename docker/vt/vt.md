### 애플리케이션 서버 ###  
하드웨어에서 실행 중인 소프트웨어
* "서버의 전원이 꺼졌습니다" -> 하드웨어 서버
* "서버 설치 파일을 다운받았습니다" -> 소프트웨어 서버

### 서버 운영 방식 ###
* 베어메탈 - 서버 위에 os 설치 후 여러 개의 소프트웨어 설치
* 하이퍼바이저
* 컨테이너 - Docker가 해당

### 가상화 기술 ###
실제로 존재하는 컴퓨터가 아니지만 마치 존재하는 것처럼 만들어주는 기술
하나의 컴퓨터에서 여러 개의 컴퓨터를 실행

#### 왜 사용?
* 가상화 기술 사용 x  
  * 어떤 한 프로그램이 에러가 나면 다른 쪽도 영향이 감
  

* 가상화 기술 사용 o 
  * 어떤 한 프로그램이 에러가 나도 서로 영향을 미치지 않음

#### 비용 효율
하드웨어 성능 증가 & 소프트웨어의 요구사항 감소
낮은 성능 여러대 < 높은 성능 한대

#### 하이퍼바이저
컴퓨터에 설치되는 프로그램  
호스트 OS에 하이퍼 바이저를 설치해 가상 환경 구축해 새로운 OS 실행하면 그것이 게스트 OS  
호스트 OS는 물리적 하드웨어와 직접 연결
게스트 OS는 호스트 OS 리소스를 나눈 논리적 공간  
게스트 OS = 가상 머신

#### 동작 원리
프로세스는 리소스를 사용해야함
하드웨어를 사용하려면 OS를 사용해야하기 때문에 커널을 이용해야함 커널에 시스템 콜을 보내 자원 사용 가능
각각 다른 OS는 다른 커널을 사용  
그러나 게스트 OS와 호스트 OS가 다르면 시스템 콜을 처리할 수 없음
`하이퍼바이저`를 통해 서로 다른 OS라도 사용 가능

### 컨테이너 가상화
현대 애플리케이션은 변경이 잦음
오버헤드가 적고 부팅이 빠른 컨테이너 가상화가 선호  

#### 하이퍼바이저 가상화  
서버 - 호스트 OS - 커널 - 하이퍼바이저 - 게스트 OS   
#### 컨테이너 가상화
서버 - 호스트 OS - 커널 - 컨테이너

하이퍼 바이저가 단계가 더 많음 -> 속도, 오버헤드 측면에서 비효율적

### 도커
컨테이너 엔진과 컨테이너 런타임으로 구성
컨테이너 엔진  
사용자의 요청을 받아 컨테이너를 관리해주는 역할

컨테이너 런타임  
직접 커널과 통신하면서 격리된 공간을 만드는 역할

도커는 RUNC라는 컨테이너 런타임을 사용  
도커는 클라이언트 - 서버 모델로 실행 (CLI, 도커 데몬)

#### 요청 흐름
1. 명령어 실행
2. 사용자 명령을 API에 맞추어 변환
3. 데몬에 API 요청 
   - 도커 데몬에게 전달 (컨테이너를 관리하는 기능 제공 = 도커 D라고도 부름)
   - 일반적으로 데몬은 서버에서 지속적으로 실행되는 소프트웨어를 말함
   - 컨테이너의 생성, 실행, 관리 등을 담당하며, 도커 클라이언트의 요청을 받아들이고 처리
4. 컨테이너 관리
5. 결과 전달
6. 결과 표시

### 컨테이너 실행
`docker version` - client, server의 버전 및 상태 확인  
`docker info` - 플러그인, 시스템 상세 정보 확인  
`docker --help` - 메뉴얼 확인  

`docker (Mangement Command) Command` - 대분류 소분류, Management는 대부분 생략 가능  
ex) docker (container) run  

`docker run (실행옵션) 이미지명` - 컨테이너 실행
실행옵션 - 컨테이너 이름이나 포트 설정 가능  
ex) docker run -p 80:80 --name hellonginx nginx

`docker rm 컨테이너명/ID` - 컨테이너 삭제  
ex) docker rm hellonginx

명령어를 CLI가 API 맞게 변환 -> 도커 데몬에게 전달 -> 컨테이너 런타임을 통해 컨테이너 실행